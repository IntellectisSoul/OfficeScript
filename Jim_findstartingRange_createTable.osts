{"version":"0.2.0","body":"//15-Dec.2023 : this creates a table by finding the usedRange. It is also 'smart enough' to be able to\n//disregard rows with 'incomplete headers', so it checks the top rows against the usedRange total number of columns.\n//Optionally, one might also use \"Option 1 : Find ID of cell Method\" to identify the starting cell  of row header.\n//Next steps to improve : test bottom row to avoid fake endcell. \n\n//-JSLim\n\nfunction main(workbook: ExcelScript.Workbook, tablename: string) {\n  // getUsedRange() : Get the active sheet and range.\n  const selectedSheet = workbook.getActiveWorksheet();\n  const FullrangeAddress = selectedSheet.getUsedRange();\n  console.log(`FullrangeAddress : ${FullrangeAddress.getAddress()}`);\n\n  // getColumnCount() : Get the total number of columns.\n  const columnCount = FullrangeAddress.getColumnCount();\n  console.log(`ColumnCount: ${columnCount}`);\n\n  //CALL FUNCTION to extract the starting and ending cell. because function returns an object of 3 (value pair)\n  // using dot notation is how to extract the objects individually\n  const extractedCells = extract_StartEndCell(FullrangeAddress.getAddress());\n  let startingCell = extractedCells.startingCell; //declare start\n  let endingCell = extractedCells.endingCell; //declear end\n  console.log(`startingCell: ${extractedCells.startingCell} | endingCell: ${extractedCells.endingCell}`);\n\n  //CALL FUNCTION to Breakdown and split the  cell address into their separate letter and number\n  let { startcell_letter, startcell_number, endcell_letter, endcell_number } = celladdress_Breakdown(startingCell, endingCell);\n\n  //CALL FUNCTION to retrieve the values of the starting row to check for Headers completion  : \n  const { values, elementCount } = getRowIndexValues(selectedSheet, (startcell_number - 1), columnCount);  //this function returns 2 objects.\n  console.log(`Values: ${values}`);\n  console.log(`Element Count: ${elementCount}`);\n\n  /*\n  //test bottom row to avoid fake endcell. identify correct endcell\n  while (true) {\n    let testrangeAddress_columnCount = testrange(startcell_letter, startcell_number, endcell_letter, selectedSheet );\n  \n    // Break the loop if testrangeAddress_columnCount equals columnCount\n    if (testrangeAddress_columnCount > (columnCount/2)) {\n      console.log(`starting Row ${startcell_letter}${startcell_number}, Header not found...moving to next row`);\n      // Increment startcell_number\n      startcell_number++;\n    } else {\n      // Define the final Range to be used to create the Table; set finalstartcell\n      let newRange = (startcell_letter + startcell_number) + \":\" + (endcell_letter + endcell_number);\n      const table = selectedSheet.addTable(newRange, true);\n      const totalRows = endcell_number - startcell_number;\n      console.log(`new Range start : ${startcell_letter}${startcell_number}, Total rows = ${totalRows}`);\n      \n      if (table) {\n        table.setName(\"TermList\");\n        console.log(`Table created successfully. Name: ${table.getName()}`);\n      } else {\n        console.log(\"Error creating table.\");\n      }\n      break;  // This will break the loop.\n    }\n  }\n  */\n\n  //test top row for header completion and then create table.\n  while (true) {\n    let testrangeAddress_columnCount = testrange(startcell_letter, startcell_number, endcell_letter, selectedSheet);\n\n    // Break the loop if testrangeAddress_columnCount equals columnCount\n    if (testrangeAddress_columnCount !== columnCount) {\n      console.log(`starting Row ${startcell_letter}${startcell_number}, Header not found...moving to next row`);\n      // Increment startcell_number\n      startcell_number++;\n    } else {\n      // Define the final Range to be used to create the Table; set finalstartcell\n      let newRange = (startcell_letter + startcell_number) + \":\" + (endcell_letter + endcell_number);\n      const table = selectedSheet.addTable(newRange, true);\n      const totalRows = endcell_number - startcell_number;\n      console.log(`new Range start : ${startcell_letter}${startcell_number}, Total rows = ${totalRows}`);\n\n      if (table) {\n        table.setName(tablename);\n        console.log(`Table created successfully. Name: ${table.getName()}`);\n      } else {\n        console.log(\"Error creating table.\");\n      }\n      break;  // This will break the loop.\n    }\n  }\n\n\n  // Check if cell is null or undefined.\n  const iscellEmpty = isCellEmpty(\"A2\", selectedSheet);\n  console.log(`Cell is empty: ${iscellEmpty}`);\n\n\n\n}\n\n// FUNCTIONS\n\n//1 : Extract starting and ending cell.\nfunction extract_StartEndCell(rangeAddress: string): { startingCell: string; endingCell: string } {\n  const parts = rangeAddress.split(\"!\");\n  const cellAddress = parts[1];\n  const cells = cellAddress.split(\":\");\n\n  // Extract starting cell\n  const startingCell = cells[0];\n  // Extract ending cell\n  const endingCell = cells[1];\n\n  // Return an object containing all extracted values\n  return { startingCell, endingCell };\n}\n\n\n\n//Unused : Check if cell is empty.\nfunction isCellEmpty(cellAddress: string, sheet: ExcelScript.Worksheet): boolean {\n  const cell = sheet.getRange(cellAddress);\n\n  // Check if the cell is null or has an undefined value or is empty.\n  return !cell || cell.getText() === '';\n\n}\n\n//2 : this function breaks down the cell address to its start and end cell.\nfunction celladdress_Breakdown(startingCell: string, endingCell: string) {\n  //Breakdown and split the  cell address into their separate letter and number\n  const startmatch = startingCell.match(/^([A-Z]+)(\\d+)$/);  //start\n  const startcell_letter = startmatch[1]; // A\n  const startcell_number = parseInt(startmatch[2]); // 3\n  console.log(`startcell_letter: ${startcell_letter} | startcell_number: ${startcell_number}`);\n\n  const endmatch = endingCell.match(/^([A-Z]+)(\\d+)$/);   //end\n  const endcell_letter = endmatch[1]; // A\n  const endcell_number = parseInt(endmatch[2]); // 3\n  console.log(`endcell_letter: ${endcell_letter} | endcell_number: ${endcell_number}`);\n\n  return { startcell_letter, startcell_number, endcell_letter, endcell_number }\n}\n\n//3: this function returns the array of the row and its elementCount.\ntype RangeValues = (string | number | boolean)[][]; //to explicitly define RangeValues because Excel needs this when type of output is not defined and it is unable to understand ExcelScript.RangeValue[]\n\nfunction getRowIndexValues(selectedSheet: ExcelScript.Worksheet, startcellnumber: number, columnCount: number): { values: RangeValues, elementCount: number } {\n\n  //function getRowIndexValues(selectedSheet: ExcelScript.Worksheet, startcellnumber: number, columnCount: number ): void {\n  const range = selectedSheet.getRangeByIndexes(startcellnumber, 0, 1, columnCount);\n  const values = range.getValues();\n  const elementCount = values[0].filter(cell => cell !== \"\").length;\n  console.log(`getRowIndexvalues of index-based row ${startcellnumber}: ${values}`);\n  console.log(`elementCount : ${elementCount}`);\n  return { values, elementCount };\n}\n\n//4: function to iterate through each row and test/count the number of elements.\nfunction testrange(startcell_letter: string, startcell_number: number, endcell_letter: string, selectedSheet: ExcelScript.Worksheet): number {\n\n  const testrangeAddress = selectedSheet.getRange(startcell_letter + startcell_number + \":\" + endcell_letter + startcell_number);\n  const testingAdddress_Range = testrangeAddress.getValues();\n  const testrangeAddress_columnCount = testingAdddress_Range[0].filter((cell: string | number | boolean) => cell !== \"\").length; //ensures empty cells are not counted\n\n  console.log(`testrangeAddress: ${testrangeAddress.getValues()}, testrangeAddress_columnCount is  ${testrangeAddress_columnCount},`);\n  return testrangeAddress_columnCount\n\n}\n","description":"","parameterInfo":"{\"version\":1,\"originalParameterOrder\":[{\"name\":\"tablename\",\"index\":0}],\"parameterSchema\":{\"type\":\"object\",\"required\":[\"tablename\"],\"properties\":{\"tablename\":{\"type\":\"string\"}}},\"returnSchema\":{\"type\":\"object\",\"properties\":{}},\"signature\":{\"comment\":\"\",\"parameters\":[{\"name\":\"workbook\",\"comment\":\"\"},{\"name\":\"tablename\",\"comment\":\"\"}]}}","apiInfo":"{\"variant\":\"synchronous\",\"variantVersion\":2}"}